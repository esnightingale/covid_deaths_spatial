---
title: "Spatio-temporal analysis of COVID-19 deaths in England"
output: html_notebook
---

```{r setup}

library(reportfactory)
library(tidyverse)
library(linelist)
library(cyphr)
library(INLA)
library(ggplot2)
library(rgdal)
library(spdep)
library(sf)
library(ggpubr)
library(patchwork)
library(viridis)
library(ggspatial)
library(spatial)
library(splines)
library(MASS)
library(gstat)
library(mgcv)

source("./code/functions.R")

datdir <- "C:/Users/phpuenig/Documents/COVID-19/Data/"

## Shapefiles
regions <- readRDS(paste0(dir,"maps/LA_shp_wpops.rds")) %>%
  filter(grepl("E", lad19cd))

regions.df <- st_drop_geometry(regions)

# Neighbourhood graph
g <- inla.read.graph(filename = paste0(dir,"maps/regions_eng.adj"))

# LTLA-week-aggregated observed deaths, expected deaths and LTLA covariates
dat <- readRDS(paste0(dir, "Deaths/dat.rds"))

```

# Preliminary

```{r temp}

dat %>%
  group_by(lad19cd) %>%
  mutate(peak = w[which.max(n)]) %>% 
  arrange(peak) %>%
 ggplot(aes(w, n, group = lad19cd, col = lad19cd)) +
  geom_vline(aes(xintercept = jitter(peak), col = lad19cd), alpha = 0.3) +
  geom_line(alpha = 0.3) +
  labs(title = "Total COVID19-related deaths in England, by week of death"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  guides(col = F) +
  scale_colour_viridis_d(option = "cividis") +
  theme_minimal() -> tot_by_wk

dat %>%
  group_by(lad19cd) %>%
  mutate(peak = wk_since_first[which.max(n)]) %>% 
  arrange(peak) %>%
 ggplot(aes(wk_since_first, n, group = lad19cd, col = lad19cd)) +
  geom_vline(aes(xintercept = jitter(peak), col = lad19cd), alpha = 0.3) +
  geom_line(alpha = 0.3) +
  labs(title = "Total COVID19-related deaths in England, by week since first LA death"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  guides(col = F) +
  scale_colour_viridis_d(option = "cividis") +
  theme_minimal() -> tot_by_epiwk

tot_by_wk 
tot_by_epiwk

dat %>%
  group_by(lad19cd) %>%
  summarise(first = unique(first)) %>% 
  full_join(regions) %>%
  basic_map(fill = "first") +
  scale_fill_viridis(option = "plasma") +
  ggtitle("Week of first death") -> first_map

dat %>%
  group_by(lad19cd) %>%
  mutate(peak = w[which.max(n)]) %>% 
  arrange(peak) %>%
  full_join(regions) %>%
  basic_map(fill = "peak") +
  scale_fill_viridis(option = "plasma") +
  ggtitle("Week of peak number of deaths") -> peak_map

first_map + peak_map

```

```{r e_wk}
dat %>%
 ggplot(aes(w, n, group = lad19cd, col = lad19cd)) +
  geom_line(alpha = 0.3) +
  geom_point(alpha = 0.3) +
  labs(title = "Total COVID19-related deaths in England, by week of death"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  guides(col = F) +
  theme_minimal() -> E_by_wk

dat %>%
 ggplot(aes(wk_since_first, n, group = lad19cd, col = lad19cd)) +
  geom_line(alpha = 0.3) +
  geom_point(alpha = 0.3) +
  labs(title = "Total COVID19-related deaths in England, by week since first LA death"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  guides(col = F) +
  theme_minimal() -> E_by_epiwk

E_by_wk 
E_by_epiwk


dat %>%
  group_by(w,geography) %>%
  summarise(n = sum(n, na.rm= T)) %>%
 ggplot(aes(w, n, group = geography, col = geography)) +
  geom_line() +
  geom_point() +
  labs(title = "Total COVID19-related deaths in England, by geography type and week of death",
       x = "Calendar week",
       colour = "Geography type"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  theme_minimal() -> E_by_wk

dat %>%
  group_by(wk_since_first,geography) %>%
  summarise(n = sum(n, na.rm= T)) %>%
 ggplot(aes(wk_since_first, n, group = geography, col = geography)) +
  geom_line() +
  geom_point() +
  labs(title = "by week since first LA death",
       x = "Weeks since first observed death",
       colour = "Geography type"
       # subtitle = paste0("Data up to ", max(lubridate::ymd(covid_deaths$dor))),
       ) +
  theme_minimal() -> E_by_epiwk

E_by_wk / E_by_epiwk

```

````{r covs}

dat <- dat %>%
  mutate(logpopdens = log(pop_dens)) 
pairs(dplyr::select(dat, IMD, prop_minority,logpopdens, prop_kw, can_mort, cv_mort, tb_inc))

```


```{r prior_setup}

# Dispersion in n
sqrt(var(dat$n))
mean(dat$n)

# Overall SD in SMR
sqrt(var(dat$SMR))

# SD over time
dat %>%
  group_by(w) %>%
  summarise(n = sum(n), E = sum(E_wk)) %>%
  mutate(SMR = n/E) %>%
  pull(SMR) %>%
  var() %>%
  sqrt() -> sd_time
sd_time

# SD over space
dat %>%
  group_by(lad19cd) %>%
  summarise(n = sum(n), E = unique(E)) %>%
  mutate(SMR = n/E) %>%
  pull(SMR) %>%
  var() %>%
  sqrt() -> sd_space
sd_space

# => Less variation over space than over time

# Undajusted for other covariates and structure so take these as upper bounds:
prior.prec.tp <- list(prec = list(prior = "pc.prec",
                               param = c(sd_time/0.31, 0.01)))
prior.prec.sp <- list(prec = list(prior = "pc.prec",
                               param = c(sd_space/0.31, 0.01)))

# Plot priors
plot(inla.pc.dprec(seq(0,100,0.01),u = sd_time/0.31, alpha = 0.01))
plot(inla.pc.dprec(seq(0,100,0.01),u = sd_space/0.31, alpha = 0.01))

```

# Model fitting

```{r formulae}

## Base model: No spatial effects, two temporal RWs, independent of geography
f_base <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw +
   #tb_inc + #cv_mort + can_mort +
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)),
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    hyper = list(prec = prior.prec.tp),
    scale.model = T)

## No spatial effect, geography-dependent RW
f_base_geog <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw +
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)), 
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    hyper = list(prec = prior.prec.tp),
    replicate = geog,
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    scale.model = T) 


## IID spatial
f_iid <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw +
   #tb_inc + #cv_mort + can_mort +
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)),
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    hyper = list(prec = prior.prec.tp),
    scale.model = T) +
 f(la, model = "iid", 
    constr = T,
    hyper=list(
      prec = prior.prec.sp
    ))

## IID spatial with geography-dependent RW
f_iid_geog <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw +
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)), 
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    hyper = list(prec = prior.prec.tp),
    replicate = geog,
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    scale.model = T) +
 f(la, model = "iid", 
    constr = T,
    hyper=list(
      prec = prior.prec.sp
    ))

## BYM spatial
f_bym <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw + 
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)),
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    hyper = list(prec = prior.prec.tp),
    scale.model = T) +
 f(la, model = "bym2", graph = g,
    scale.model = T,
    constr = T,
    hyper=list(
      phi =list(param =c(0.5, 2/3)),
      prec = prior.prec.sp) 
    )

## BYM spatial effect, geography-dependent RW
f_bym_geog <- n ~ 
   IMD + prop_minority + log(pop_dens) + prop_kw + 
  f(w, model = "rw1",
    hyper = list(prec = prior.prec.tp),
    values = seq(min(dat$w),max(dat$w)),   
    scale.model = T) +
  f(wk_since_first, model = "rw2",
    hyper = list(prec = prior.prec.tp),
    replicate = geog,
    values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
    scale.model = T) +
 f(la, model = "bym2", graph = g,
    scale.model = T,
    constr = T,
    hyper=list(
      phi =list(param =c(0.5, 2/3)),
      prec = prior.prec.sp) 
    )

## BYM spatial effect, replicated temporal RW, no covariates
# f_rep_bym_nocovs <- n ~ 
#   f(w, model = "rw1",
#     hyper = list(prec = prior.prec.tp),
#     values = seq(min(dat$w),max(dat$w)),
#     scale.model = T) +
#   f(wk_since_first, model = "rw2",
#     values = seq(min(dat$wk_since_first),max(dat$wk_since_first)),
#     hyper = list(prec = prior.prec.tp),
#     scale.model = T) +
#  f(la, model = "bym2", graph = g,
#     replicate = geog,
#     scale.model = T,
#     constr = T,
#     hyper=list(
#       phi =list(param =c(0.5, 2/3)),
#       prec = prior.prec.sp) 
#       )


## Model specification ##
fit_mod <- function(f){
  fit <- inla(f,
              "nbinomial",
              data= dat,
              E = E_wk,
              # offset = log(la_age_pop),
              control.compute=list(dic=TRUE, 
                                   waic=TRUE, 
                                   cpo = TRUE,
                                   config = TRUE),
              control.fixed=list(mean=0, prec=0.1, mean.intercept=0, prec.intercept=0.001),
  verbose = T)
  return(fit)
}

## Fit all formulae ##
formulae <- list(base = f_base, base_geog = f_base_geog, iid = f_iid, iid_geog = f_iid_geog, BYM = f_bym, BYM_geog = f_bym_geog)
fits <- lapply(formulae, fit_mod)

saveRDS(fits, file = "./fits/fits_list_final.rds")

## Draw posterior samples ##
samples <- lapply(fits, inla.posterior.sample,n = 1000)
saveRDS(samples, file = "./fits/samples_list_final.rds")

```

# Model comparison

```{r plot_mods}
# 
# pdf(file = "./figures/final/plot_fits.pdf")
# for(f in fits){
#   plot(f, plot.prior = TRUE)
# }
# dev.off()

plot(fits[["BYM_geog"]], plot.prior = TRUE)

```

## WAIC/log score

```{r comp_mods}

model_comp <- data.frame(WAIC = sapply(fits, function(m){return(m$waic$waic)}),
                         logs = sapply(fits, function(m){return(-mean(log(m$cpo$cpo)))})) %>% 
  rownames_to_column(var = "Model")

model_comp %>%
 mutate(diff_WAIC = WAIC - min(WAIC),
        diff_logs = logs - min(logs)) %>%
  arrange(diff_WAIC) %>%
  dplyr::select(-WAIC, -logs)

```


## Variogram

Incorrect specification?

```{r variogram}

coords <- sf::st_coordinates(sf::st_centroid(regions)) %>%
  as.data.frame() %>%
  bind_cols(dplyr::select(st_drop_geometry(regions),lad19cd))

get_resid <- function(mod){
  dat %>% 
  mutate(mu = fits[[mod]]$summary.fitted.values$mean,
         sigma2 = mu*(1 + mu/fits[[mod]]$summary.hyperpar[1,"mean"]),
         resid = (SMR-mu)/sqrt(sigma2)) %>%
    pull(resid)
}

modnames <- names(fits)
resids <- lapply(modnames, get_resid) %>%
  bind_cols() %>%
  setNames(unlist(modnames))

dat_coord <- full_join(dat, coords) %>%
  bind_cols(resids)
coordinates(dat_coord) <- ~ X+Y

proj4string(dat_coord) = CRS("+init=epsg:27700 +units=m +no_defs")
# plot(dat_coord)

names(modnames) <- names(fits)
v.list <- lapply(modnames, function(var){ variogram(as.formula(paste0(var,"~ 1")), dat_coord) }) %>%
  bind_rows(.id = "Model")

v0 <- variogram(SMR~1, dat_coord) %>%
  mutate(Model = "none")

ggplot(v0,aes(x = dist, y = gamma)) +
  geom_point() +
  geom_line() +
  labs(y = "variance", title = "Raw SMR")

v.list %>%
ggplot(aes(x = dist, y = gamma, col = Model)) +
  geom_point() +
  geom_line() +
  labs(y = "variance", title = "Model residuals")

```

## Summarise fit

Explore observed versus fitted values and error 

```{r summ}

# fits <- list(rep_iid = fits[["rep_iid"]])

for (fit in seq_along(fits)){

pdf(paste0("./figures/final_altdata/fit_summ_",names(fits)[[fit]],".pdf"))
# pdf(paste0("./figures/0408/fit_summ_","repgeog",".pdf"))

summary(fits[[fit]]) %>% print()

pit_hist(fits[[fit]]) %>% print()


dat$fitted <- fits[[fit]]$summary.fitted.values[,"mean"]
dat$fitted_sd <- fits[[fit]]$summary.fitted.values[,"sd"]

get_error <- function(x){
  error <- (dat$n - (x*dat$E_wk))/sqrt(x*dat$E_wk)
}

# error <- inla.tmarginal(get_error, fit_main$marginals.fitted.values)

dat %>%
  mutate(mu = fitted*E_wk,
         P.resid = (n - mu)/sqrt(mu*(1 + (mu/fits[[fit]]$summary.hyperpar[1,"mean"]))),
         raw.err = (n - mu)) -> dat

print(
dat%>%
  ggplot(aes(n, fitted*E_wk)) +
  geom_point(alpha = 0.1) + 
  geom_smooth() + 
  geom_hline(yintercept = 0)
) #%>% print()

print(
dat%>%
  ggplot(aes(n, P.resid)) +
  geom_point(alpha = 0.1) + 
  geom_smooth() + 
  geom_hline(yintercept = 0, col = "red", lty = "dashed") +
  scale_x_continuous(trans = "log") +
  geom_hline(yintercept = 0)
) #%>% print()

print(
dat %>%
  ggplot(aes(n, raw.err)) +
  geom_point(alpha = 0.1) + 
  geom_smooth() + 
  geom_hline(yintercept = 0, col = "red", lty = "dashed") +
  scale_x_continuous(trans = "log") +
  geom_hline(yintercept = 0)
) #%>% print()

print(
dat%>%
  ggplot(aes(w, raw.err)) +
  geom_point(alpha = 0.1) + 
  # geom_jitter() + 
  geom_smooth() + 
  geom_hline(yintercept = 0)
) #%>% print()

print(
dat%>%
  ggplot(aes(wk_since_first, raw.err)) +
  geom_point(alpha = 0.1) + 
  # geom_jitter() + 
  geom_smooth() + 
  geom_hline(yintercept = 0)
) #%>% print()

print(
dat %>%
group_by(lad19cd) %>%
  summarise(P.resid = mean(P.resid)) %>%
  left_join(regions) %>%
  basic_map(fill = "P.resid") +
  labs(title = "Mean standardised error (Pearson residual) per local authority")
) #%>% print()

-mean(log(fits[[fit]]$cpo$cpo))

dev.off()
}


```


# Posterior samples

```{r ppd}

samples <- lapply(fits, inla.posterior.sample,n = 1000)
saveRDS(samples, file = "./fits/samples_list_final.rds")

```


# Summary posterior distribution

Plot sampled trajectories over time and posterior parameter distributions.

```{r plot_ppd}

# samples <- inla.posterior.sample(fits[["rep_iid"]], n = 1000)
# samples <- list(rep_iid = samples)

nval <- nrow(dat)

get_preds <- function(sample){
  pred <- sample$latent[1:nval]
}

for (s in seq_along(samples)){

preds <- bind_cols(lapply(samples[[s]], get_preds))

pdf(paste0("./figures/final_altdata/summ_post_", names(fits)[s],".pdf"))

hist(exp(as.matrix(preds))*dat$E_wk, breaks = 30, xlim = c(0,200), prob = T)
hist(dat$n, breaks = 30, xlim = c(0,200), prob = T)

dat_pred <- bind_cols(dplyr::select(dat, geography, lad19cd, lad19nm, la, w, E_wk, n), preds) %>%
  pivot_longer(cols = -1:-7) %>%
  mutate(value = exp(value)*E_wk)

print(
dat_pred %>%
  group_by(w, name) %>%
  summarise(value = sum(value),
            n = sum(n)) %>%
  ggplot() + 
  geom_line(aes(w, value, group = name), alpha = 0.1, col = "grey") +
  geom_point(aes(w, n)) + 
  theme_minimal()
)

print(
dat_pred %>%
  group_by(w, name, geography) %>%
  summarise(value = sum(value),
            n = sum(n)) %>%
  ggplot() + 
  geom_line(aes(w, value, group = name, col = geography), alpha = 0.1, col = "grey") +
  geom_point(aes(w, n)) + 
  facet_wrap(~geography) +
  theme_minimal()
)

# la_samp <- sample(dat$la,9)
la_samp <- unique(dat$la[dat$lad19nm %in% c("Liverpool", "Bromley","Bedford", "Allerdale","Wigan","Epping Forest")])
print(
dat_pred %>%
  filter(la %in% la_samp) %>%
  ggplot() + 
  geom_line(aes(w, value, group = name), alpha = 0.1, col = "grey") +
  geom_point(aes(w, n)) + 
  facet_wrap(~lad19nm) +
  theme_minimal()
)


plot_parm <- function(parm, opt = 1){
  
 if (opt == 1){ d <- fits[[s]]$marginals.fixed[[parm]]
 }else{ d <- fits[[s]]$marginals.hyperpar[[parm]] }
  
 print(
  ggplot(data.frame(inla.smarginal(d)), aes(x, y)) +
  geom_line() +
  geom_vline(xintercept = 0, col = "red", lty = "dashed") +
  labs(title = parm) +
  theme_bw()
 )
}

lapply(names(fits[[s]]$marginals.fixed), plot_parm, opt = 1)

lapply(names(fits[[s]]$marginals.hyperpar), plot_parm, opt = 2)

dev.off()

print(s)
}
```



```{r fit_maps}

dat$fitted <- fits[[3]]$summary.fitted.values[,"mean"]
dat$fitted_sd <- fits[[3]]$summary.fitted.values[,"sd"]

preds <- bind_cols(lapply(samples[[3]], get_preds))

dat_pred <- bind_cols(dplyr::select(dat, geography, lad19cd, lad19nm, la, w, E, E_wk, n), preds) %>%
  pivot_longer(cols = -1:-7, values_to = "fitted") %>%
  mutate(deaths = exp(fitted)*E_wk,
         exp_fit = exp(fitted)) 

dat_pred_agg <- dat_pred %>%
  group_by(geography, lad19cd, lad19nm, la, E, name) %>%
  summarise(tot_fit = sum(fitted),
            tot_exp_fit = sum(exp_fit),
            tot_deaths = sum(deaths)) %>%
  group_by(geography, lad19cd, lad19nm, la, E) %>%
  summarise(mean_fit = mean(tot_fit),
            mean_exp_fit = mean(tot_exp_fit),
            pred_deaths = mean(tot_deaths)) 

png("./figures/final/fit_reprw_bywk.png", height = 1000, width = 1000)
regions %>%
  full_join(dat) %>% 
  basic_map(fill = "fit_deaths") + facet_wrap(~w)
dev.off()

regions %>%
  full_join(dat_pred_agg) %>% 
  basic_map(fill = "pred_deaths") +
  labs(title = "Mean predicted deaths per LTLA") -> fit_map_pred

regions %>%
  full_join(dat_pred_agg) %>% 
  basic_map(fill = "mean_fit") +
  labs(title = "Fitted SMR per LTLA") -> fit_map_deaths

png("./figures/final/fit_reprw.png", height = 1000, width = 1000)
fit_map_pred + fit_map_deaths
dev.off()


```

```{r temp_re}

fit <- fits[[3]]
preds <- bind_cols(lapply(samples[[3]], get_preds))
dat_pred <- bind_cols(dplyr::select(dat, geography, lad19nm, la, w, wk_since_first, E_wk, n), preds) %>%
  pivot_longer(cols = -1:-7) %>%
  mutate(value = exp(value)*E_wk)

pdf(paste0("./figures/final_altdata/summ_time_", names(fits)[3],".pdf"))
dat_pred %>%
  group_by(w, name) %>%
  summarise(value = sum(value),
            n = sum(n)) %>%
  ggplot() + 
  geom_line(aes(w, value, group = name), alpha = 0.1, col = "grey") +
  geom_point(aes(w, n)) + 
  labs(x = "Calendar week", y = "Total deaths", title = "Total fit over time, by calendar week", subtitle = "Observed counts shown in black, with 1000 posterior samples in grey") +
  theme_minimal() -> plot_fit_time

dat_pred %>%
  group_by(w, name, geography) %>%
  summarise(value = sum(value),
            n = sum(n)) %>%
  mutate(group = paste0(name, geography)) -> by_samp_geog
by_samp_geog %>%
  group_by(w, geography) %>%
  summarise(value = mean(value),
            n = mean(n)) -> by_geog

ggplot(by_samp_geog) + 
  geom_line(aes(w, value, group = group, col = geography), alpha = 0.1) +
  geom_point(dat = by_geog, aes(w, n, col = geography), pch = 21, fill = "white") + 
  labs(x = "Calendar week", y = "Total deaths", title = "Total fit over time, by calendar week and geography", subtitle = "Observed counts shown in white, with 1000 posterior samples", col = "Geography") +
  theme_minimal() -> plot_fit_time_geog


length(fit$marginals.random$w)
length(fit$marginals.random$wk_since_first)

# dat_w <- data.frame(w = sort(unique(dat$wk_since_first)),
#                     trend=fit$summary.random$wk_since_first$mean,
#                     Model = "Week since first death") %>%
#          bind_rows(bind_cols(expand.grid(w = seq(min(dat$w),max(dat$w)), geography = sort(unique(dat$geography))),
#                              data.frame(trend = fit$summary.random$w$mean,
#                                         Model = "Calendar week")))

dat_w <- data.frame(w = sort(unique(dat$w)),
                    trend=fit$summary.random$w$mean,
                    Model = "Calendar week") %>%
         bind_rows(bind_cols(expand.grid(w = seq(min(dat$wk_since_first),max(dat$wk_since_first)), geography = sort(unique(dat$geography))),
                             data.frame(trend = fit$summary.random$wk_since_first$mean,
                                        Model = "Week since first death"))) %>%
  mutate(geography = factor(replace_na(as.character(geography), "All"),
                            levels = c("London Borough","Metropolitan District","Non-metropolitan District","Unitary Authority","All")))

dat_w %>%
  # filter(Model == "Wk since first" & w>=0) %>%
ggplot(aes(w, trend, col = geography)) +
  geom_line() +
  geom_hline(yintercept = 0, col = "grey", lty = "dashed") +
  facet_grid(cols = vars(Model), scales = "free") + 
  labs(x = "", col = "Geography", y = "Trend") +
  theme_minimal() -> plot_rw
  
plot_rw
dev.off()

plot_rw

```

```{r bym2_sp_re}

# plot_fit(fit_main, dat)

length(fit$marginals.random$la)
n.re <- n_distinct(dat$lad19cd)
la.id <- dplyr::select(dat, la, lad19cd) %>% unique() %>% mutate(la = as.factor(la))

get_re_sp <- function(m, idx){
  exp.z <- unlist(lapply(m$marginals.random$la[idx], #indices for spatial component
                 function(x) inla.emarginal(exp,x)))
  out <- data.frame(
  la = as.factor(as.numeric(gsub("index.","",names(exp.z)))-n.re),
  exp.z = exp.z
  )
  return(out)
}

sp_eff <- get_re_sp(fit, idx = n.re+1:n.re) %>%
  rename(structured = exp.z) %>%
  mutate(total_re = get_re_sp(fit, idx = 1:n.re)$exp.z,
         unstructured = total_re - structured) %>%
  full_join(la.id) 

hist(sp_eff$structured)
hist(sp_eff$unstructured)

# Relative contribution of components - what are x and y?
# summary(fit_main$marginals.hyperpar$`Precision for la`)
# summary(fit_main$marginals.hyperpar$`Phi for la`)

sp_eff %>%
  pivot_longer(cols = c("structured","unstructured")) %>%
  full_join(regions) %>%
  basic_map(fill = "value") +
  facet_wrap(~name) +
  ggtitle("Spatial random effects") -> bym2_re


png("./figures/final/spatialRE_finalmod.png", height = 1000, width = 1300)
bym2_re
dev.off()

bym2_re
```

```{r fit_re}

sp_eff %>%
  full_join(regions) %>%
  basic_map(fill = "total_re") +
  ggtitle("Total spatial random effect") -> re_map

fit_map + re_map

```


## Compare different prior specifications

```{r plot_reff_fcn}

# get_re_sp <- function(m){
#   exp.z <- unlist(lapply(m$marginals.random$la[n.re+1:n.re], #indices for spatial component
#                  function(x) inla.emarginal(exp,x)))
#   out <- data.frame(
#     la = as.factor(as.numeric(gsub("index.","",names(exp.z)))-n.re),
#     exp.z = exp.z
#   )
#   return(out)
# }
# 
# plot_fit <- function(fit, data){
#   
# print()
# 
# length(fit$marginals.random$la)
# n.re <- n_distinct(data$lad19cd)
# la.id <- dplyr::select(data, la, lad19cd) %>% unique() %>% mutate(la = as.factor(la))
# 
# sp_eff <- get_re_sp(fit) %>%
#   full_join(la.id) %>% # bind with LA code for merge with shape
#   full_join(regions)
# 
# # hist(sp_eff$exp.z)
# 
# # Relative contribution of components - what are x and y?
# summary(fit$marginals.hyperpar$`Precision for la`)
# summary(fit$marginals.hyperpar$`Phi for la`)
# 
# reffmap <- basic_map(sp_eff, fill = "exp.z") +
#   ggtitle("Spatial random effects")
# 
# # ggsave("./figures/pop_adj/bym2_sp.png", bym2_re)
# 
# return(list(reffmap))
# }

```

```{r sensitivity}

# run_mod <- function(U = 0.5, p = 2/3, V = 12, q = 0.5){
#   
# priors <- list(prec = list(param = c(V, q)), phi = list(param = c(U, p)))
# 
# f <- n ~ 1 +
#   f(w, model = "rw1",
#     values = seq(min(dat$w),max(dat$w)),
#     scale.model = T) +
#   f(w2, model = "rw2",
#     values = seq(min(dat$w),max(dat$w)),
#     scale.model = T) +
#   f(la, model = "bym2", graph = g,
#     scale.model = T,
#     constr = T,
#     hyper = priors)
# 
# fit <- inla_main("nbinomial", f, dat)
# 
# sp_eff_bym2 <- get_re_sp(fit) %>%
#   full_join(la.id) %>% # bind with LA code for merge with shape
#   full_join(regions)
# 
# # Relative contribution of components - what are x and y?
# # print(summary(fit$marginals.hyperpar$`Precision for la`))
# # print(summary(fit$marginals.hyperpar$`Phi for la`))
# 
# bym2_re <- basic_map(sp_eff_bym2, fill = "exp.z") +
#   ggtitle("BYM2 spatial random effects") +
#   scale_fill_gradient2()
# 
# print(bym2_re)
# 
# return(fit)
# }
# 
# result1 <- run_mod()
# 
# parms <- expand.grid(U = 0.5, p = c(0.5,2/3), V = 1, q = 0.01)
# prior.list <- list()
# for (i in 1:nrow(parms)){
#   prior = list(phi = list(param = c(parms[i,1], parms[i,2])), prec = list(param = c(parms[i,3], parms[i,4])))
#   prior.list <- rlist::list.append(prior.list, prior)
# }
# 
# result <- lapply(prior.list, function(prior) {
#   
# f <- n ~ 1 +
#   f(w, model = "rw1", 
#     values = seq(min(dat$w),max(dat$w)), 
#     scale.model = T) +
#   f(w2, model = "rw2",
#     values = seq(min(dat$w),max(dat$w)), 
#     scale.model = T) +
#   f(la, model = "bym2", graph = g,
#     scale.model = T,
#     constr = T,
#     hyper=prior)
# 
# inla_main("nbinomial", f, dat)
# 
# })
# 
# 
# sp_eff_bym2 <- get_re_sp(fit) %>%
#   full_join(la.id) %>% # bind with LA code for merge with shape
#   full_join(regions)
# 
# # Relative contribution of components - what are x and y?
# # print(summary(fit$marginals.hyperpar$`Precision for la`))
# # print(summary(fit$marginals.hyperpar$`Phi for la`))
# 
# bym2_re <- basic_map(sp_eff_bym2, fill = "exp.z") +
#   ggtitle("BYM2 spatial random effects") +
#   scale_fill_gradient2()
# 
# maps[[1]] <- bym2_re
# 
# print(bym2_re)

```

